<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ぷにぷに風ゲーム</title>
    <style>
        body { text-align: center; }
        #gameCanvas { border: 1px solid black; width: 500px; height: 500px; }
        .score, .timer { font-size: 20px; margin: 10px; }
        .timer { position: absolute; top: 10px; right: 10px; }
    </style>
</head>
<body>
    <h1>ぷにぷに風ゲーム</h1>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <div class="score">Score: <span id="score">0</span></div>
    <div class="timer">Time: <span id="timer">0</span>s</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['red', 'blue', 'green', 'yellow'];
        let balls = [];
        const radius = 20;
        const growTime = 3000;  // 3秒以上接触で合体
        let score = 0;
        let timeElapsed = 0;

        // タイマーの更新
        setInterval(() => {
            timeElapsed++;
            document.getElementById('timer').textContent = timeElapsed;
        }, 1000);

        // Matter.jsエンジンの作成
        const engine = Matter.Engine.create();
        const world = engine.world;

        // 円形領域の設定
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const boundaryRadius = 200;

        // 円形領域の描画
        function drawCircularBoundary() {
            ctx.beginPath();
            ctx.arc(centerX, centerY, boundaryRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ボールを生成
        function createBall(x, y, color) {
            const ball = Matter.Bodies.circle(x, y, radius, {
                restitution: 0.8,
                render: { fillStyle: color }
            });
            ball.color = color;
            ball.touching = {};  // 接触中のボールと接触開始時間を保持
            balls.push(ball);
            Matter.World.add(world, ball);
        }

        // 指定した数のボールをランダムに生成
        function addBalls(count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * (boundaryRadius - radius);
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                const color = colors[Math.floor(Math.random() * colors.length)];
                createBall(x, y, color);
            }
        }

        // 初期ボールの配置
        addBalls(10);

        // 合体処理：3秒以上接触した同色ボールを一つの大きなボールにする
        function checkAndCombineBalls() {
            const toCombine = [];

            balls.forEach((ball, index) => {
                for (let j = index + 1; j < balls.length; j++) {
                    const otherBall = balls[j];
                    if (ball.color === otherBall.color) {
                        const collision = Matter.SAT.collides(ball, otherBall);
                        if (collision.collided) {
                            if (!ball.touching[otherBall.id]) {
                                ball.touching[otherBall.id] = Date.now();
                            }
                            const elapsedTime = Date.now() - ball.touching[otherBall.id];
                            if (elapsedTime >= growTime) {
                                toCombine.push({ ball1: ball, ball2: otherBall });
                            }
                        } else {
                            ball.touching[otherBall.id] = null;
                        }
                    }
                }
            });

            // 合体リストを処理
            toCombine.forEach(({ ball1, ball2 }) => {
                const newRadius = Math.sqrt(Math.pow(ball1.circleRadius, 2) + Math.pow(ball2.circleRadius, 2));
                const newX = (ball1.position.x + ball2.position.x) / 2;
                const newY = (ball1.position.y + ball2.position.y) / 2;

                const combinedBall = Matter.Bodies.circle(newX, newY, newRadius, {
                    restitution: 0.8,
                    render: { fillStyle: ball1.color }
                });
                combinedBall.color = ball1.color;

                // 元のボールを削除し、新しいボールを追加
                Matter.World.remove(world, ball1);
                Matter.World.remove(world, ball2);
                balls = balls.filter(b => b !== ball1 && b !== ball2);
                balls.push(combinedBall);
                Matter.World.add(world, combinedBall);
            });
        }

        // 4つ以上の連続削除と新しいボール追加
        function checkAndRemoveBalls() {
            const toRemove = [];
            balls.forEach(ball => {
                const connectedBalls = balls.filter(otherBall =>
                    otherBall.color === ball.color &&
                    Matter.SAT.collides(ball, otherBall).collided
                );

                if (connectedBalls.length >= 4) {
                    toRemove.push(...connectedBalls);
                    score += Math.PI * Math.pow(ball.circleRadius, 2) * connectedBalls.length;
                }
            });

            if (toRemove.length > 0) {
                const removedCount = toRemove.length;
                toRemove.forEach(ball => {
                    Matter.World.remove(world, ball);
                });
                balls = balls.filter(ball => !toRemove.includes(ball));
                addBalls(removedCount + 2);
                document.getElementById('score').textContent = Math.round(score);
            }
        }

        // Matter.jsの更新ループ
        Matter.Engine.run(engine);

        // 描画ループ
        (function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawCircularBoundary();

            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.position.x, ball.position.y, ball.circleRadius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                ctx.closePath();
            });

            checkAndCombineBalls();
            checkAndRemoveBalls();

            requestAnimationFrame(render);
        })();

        // デバイスの傾きによって重力方向を変更
        window.addEventListener('deviceorientation', (event) => {
            const { beta, gamma } = event;

            const gravityX = Math.sin(gamma * (Math.PI / 180));
            const gravityY = Math.sin(beta * (Math.PI / 180));

            world.gravity.x = gravityX;
            world.gravity.y = gravityY;
        });

        // タッチ操作でボールをドラッグ可能に
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                const dx = x - ball.position.x;
                const dy = y - ball.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= ball.circleRadius) {
                    Matter.Body.setStatic(ball, true);
                    ball.isDragging = true;
                }
            });
        });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setPosition(ball, { x, y });
                }
            });
            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setStatic(ball, false);
                    ball.isDragging = false;
                }
            });
        });

        // 円形の境界にボールが入るよう制約を加える
        Matter.Events.on(engine, 'beforeUpdate', () => {
            balls.forEach(ball => {
                const dx = ball.position.x - centerX;
                const dy = ball.position.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > boundaryRadius - ball.circleRadius) {
                    const angle = Math.atan2(dy, dx);
                    Matter.Body.setPosition(ball, {
                        x: centerX + (boundaryRadius - ball.circleRadius) * Math.cos(angle),
                        y: centerY + (boundaryRadius - ball.circleRadius) * Math.sin(angle)
                    });
                }
            });
        });
    </script>
</body>
</html>
