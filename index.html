<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>レスポンシブデザインぷにぷに風ゲーム</title>
    <style>
        body { text-align: center; }
        #gameCanvas { border: 1px solid black; max-width: 90vw; max-height: 90vh; }
        .score { font-size: 20px; margin: 10px; }
    </style>
</head>
<body>
    <h1>レスポンシブデザインぷにぷに風ゲーム</h1>
    <canvas id="gameCanvas"></canvas>
    <div class="score">Score: <span id="score">0</span></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['red', 'blue', 'green', 'yellow'];
        const balls = [];
        const radius = 20;
        const growTime = 3000;  // 3秒以上接触で大きくなる
        let score = 0;

        // レスポンシブキャンバスの設定
        const updateCanvasSize = () => {
            canvas.width = Math.min(window.innerWidth * 0.9, 500);
            canvas.height = Math.min(window.innerHeight * 0.9, 500);
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            boundaryRadius = Math.min(canvas.width, canvas.height) / 2 - 20;
            drawCircularBoundary();
        };

        window.addEventListener('resize', updateCanvasSize);
        updateCanvasSize();

        // Matter.jsエンジンの作成
        const engine = Matter.Engine.create();
        const world = engine.world;

        // 円形領域の設定
        let centerX = canvas.width / 2;
        let centerY = canvas.height / 2;
        let boundaryRadius = Math.min(canvas.width, canvas.height) / 2 - 20;

        // 円形領域の描画
        function drawCircularBoundary() {
            ctx.beginPath();
            ctx.arc(centerX, centerY, boundaryRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ボールを生成
        function createBall(x, y, color) {
            const ball = Matter.Bodies.circle(x, y, radius, {
                restitution: 0.8,
                render: { fillStyle: color }
            });
            ball.color = color;
            ball.touching = {};
            balls.push(ball);
            Matter.World.add(world, ball);
        }

        // 初期ボールの配置
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * (boundaryRadius - radius);
            const x = centerX + r * Math.cos(angle);
            const y = centerY + r * Math.sin(angle);
            const color = colors[Math.floor(Math.random() * colors.length)];
            createBall(x, y, color);
        }

        // 接触時間と4つ以上の連続したボールの削除チェック
        function checkAndUpdateBalls() {
            let toRemove = [];
            balls.forEach(ball => {
                balls.forEach(otherBall => {
                    if (ball !== otherBall && ball.color === otherBall.color) {
                        const collision = Matter.SAT.collides(ball, otherBall);
                        if (collision.collided) {
                            if (!ball.touching[otherBall.id]) {
                                ball.touching[otherBall.id] = Date.now();
                            }
                            const elapsedTime = Date.now() - ball.touching[otherBall.id];
                            if (elapsedTime >= growTime) {
                                Matter.Body.scale(ball, 1.4, 1.4);
                                Matter.Body.scale(otherBall, 1.4, 1.4);
                                ball.touching[otherBall.id] = null;
                            }
                        } else {
                            ball.touching[otherBall.id] = null;
                        }
                    }
                });
            });

            // 4つ以上連続の削除とスコア加算
            balls.forEach((ball, index) => {
                const connectedBalls = balls.filter(otherBall =>
                    otherBall.color === ball.color &&
                    Matter.SAT.collides(ball, otherBall).collided
                );

                if (connectedBalls.length >= 4) {
                    toRemove = toRemove.concat(connectedBalls);
                    score += Math.PI * Math.pow(ball.circleRadius, 2) * connectedBalls.length;
                }
            });

            toRemove.forEach(ball => {
                Matter.World.remove(world, ball);
                balls.splice(balls.indexOf(ball), 1);
            });
            document.getElementById('score').textContent = Math.round(score);
        }

        // Matter.jsの更新ループ
        Matter.Engine.run(engine);

        // 描画ループ
        (function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawCircularBoundary();

            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.position.x, ball.position.y, ball.circleRadius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                ctx.closePath();
            });

            checkAndUpdateBalls();

            requestAnimationFrame(render);
        })();

        // デバイスの傾きによって重力方向を変更
        window.addEventListener('deviceorientation', (event) => {
            const { beta, gamma } = event;

            const gravityX = Math.sin(gamma * (Math.PI / 180));
            const gravityY = Math.sin(beta * (Math.PI / 180));

            world.gravity.x = gravityX;
            world.gravity.y = gravityY;
        });

        // タッチ操作でボールをドラッグ可能に
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                const dx = x - ball.position.x;
                const dy = y - ball.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= ball.circleRadius) {
                    Matter.Body.setStatic(ball, true);
                    ball.isDragging = true;
                }
            });
        });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setPosition(ball, { x, y });
                }
            });
            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setStatic(ball, false);
                    ball.isDragging = false;
                }
            });
        });

        // 円形の境界にボールが入るよう制約を加える
        Matter.Events.on(engine, 'beforeUpdate', () => {
            balls.forEach(ball => {
                const dx = ball.position.x - centerX;
                const dy = ball.position.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > boundaryRadius - ball.circleRadius) {
                    const angle = Math.atan2(dy, dx);
                    Matter.Body.setPosition(ball, {
                        x: centerX + (boundaryRadius - ball.circleRadius) * Math.cos(angle),
                        y: centerY + (boundaryRadius - ball.circleRadius) * Math.sin(angle)
                    });
                }
            });
        });
    </script>
</body>
</html>
