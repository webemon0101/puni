<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>デバイス向きによる重力操作</title>
    <style>
        body { text-align: center; }
        #gameCanvas { border: 1px solid black; }
        .score { font-size: 20px; margin: 10px; }
    </style>
</head>
<body>
    <h1>デバイス向きによる重力操作</h1>
    <canvas id="gameCanvas" width="500" height="500"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['red', 'blue', 'green', 'yellow'];
        const balls = [];
        const radius = 20;
        const growTime = 3000;  // 同色のボールが3秒以上接触すると大きくなる

        // Matter.jsエンジンの作成
        const engine = Matter.Engine.create();
        const world = engine.world;

        // 丸い境界領域
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const boundaryRadius = 200;

        // ボールを生成
        function createBall(x, y, color) {
            const ball = Matter.Bodies.circle(x, y, radius, {
                restitution: 0.8,
                render: { fillStyle: color }
            });
            ball.color = color;
            ball.touchStartTime = null;
            balls.push(ball);
            Matter.World.add(world, ball);
        }

        // 初期ボールの配置
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * (boundaryRadius - radius);
            const x = centerX + r * Math.cos(angle);
            const y = centerY + r * Math.sin(angle);
            const color = colors[Math.floor(Math.random() * colors.length)];
            createBall(x, y, color);
        }

        // 同色のボールの接触時間を確認し、条件を満たせばサイズを大きくする
        function checkAndGrowBalls() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ballA = balls[i];
                    const ballB = balls[j];
                    if (ballA.color === ballB.color && Matter.SAT.collides(ballA, ballB).collided) {
                        if (!ballA.touchStartTime) {
                            ballA.touchStartTime = Date.now();
                        }
                        if (!ballB.touchStartTime) {
                            ballB.touchStartTime = Date.now();
                        }

                        const elapsedA = Date.now() - ballA.touchStartTime;
                        const elapsedB = Date.now() - ballB.touchStartTime;

                        if (elapsedA >= growTime && elapsedB >= growTime) {
                            Matter.Body.scale(ballA, 1.4, 1.4);
                            Matter.Body.scale(ballB, 1.4, 1.4);
                            ballA.touchStartTime = null;
                            ballB.touchStartTime = null;
                        }
                    } else {
                        ballA.touchStartTime = null;
                        ballB.touchStartTime = null;
                    }
                }
            }
        }

        // Matter.jsの更新ループ
        Matter.Engine.run(engine);

        // 描画ループ
        (function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 円形領域の描画
            ctx.beginPath();
            ctx.arc(centerX, centerY, boundaryRadius, 0, Math.PI * 2);
            ctx.stroke();

            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.position.x, ball.position.y, ball.circleRadius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                ctx.closePath();
            });

            checkAndGrowBalls();

            requestAnimationFrame(render);
        })();

        // デバイスの傾きによって重力方向を変更
        window.addEventListener('deviceorientation', (event) => {
            const { beta, gamma } = event;

            // beta（前後の傾き）とgamma（左右の傾き）を基に重力の向きを計算
            const gravityX = Math.sin(gamma * (Math.PI / 180));
            const gravityY = Math.sin(beta * (Math.PI / 180));

            world.gravity.x = gravityX;
            world.gravity.y = gravityY;
        });

        // タッチ操作でボールをドラッグ可能に
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                const dx = x - ball.position.x;
                const dy = y - ball.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= ball.circleRadius) {
                    // ドラッグ対象のボールを指定
                    Matter.Body.setStatic(ball, true);
                    ball.isDragging = true;
                }
            });
        });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const x = touch.clientX - canvas.offsetLeft;
            const y = touch.clientY - canvas.offsetTop;

            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setPosition(ball, { x, y });
                }
            });
            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            balls.forEach(ball => {
                if (ball.isDragging) {
                    Matter.Body.setStatic(ball, false);
                    ball.isDragging = false;
                }
            });
        });

        // 円形の境界にボールが入るよう制約を加える
        Matter.Events.on(engine, 'beforeUpdate', () => {
            balls.forEach(ball => {
                const dx = ball.position.x - centerX;
                const dy = ball.position.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > boundaryRadius - ball.circleRadius) {
                    const angle = Math.atan2(dy, dx);
                    Matter.Body.setPosition(ball, {
                        x: centerX + (boundaryRadius - ball.circleRadius) * Math.cos(angle),
                        y: centerY + (boundaryRadius - ball.circleRadius) * Math.sin(angle)
                    });
                }
            });
        });
    </script>
</body>
</html>
